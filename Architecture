# Book Translation App - Architecture Document

**Version 2.0 | December 2025**

---

## 1. Executive Summary

A Streamlit app that translates illustrated books from English to Hebrew. Users upload a folder of page images; the app extracts text, translates it, and regenerates each image with Hebrew text while preserving the original artwork.

**Core Pipeline:**
1. User uploads folder of images (or selects path)
2. For each image: Extract + Translate text (one API call)
3. Check if we've seen this text before (deduplication)
4. If new: Edit the original image - swap English text for Hebrew (preserves all artwork)
5. Save translated image to output folder

---

## 2. System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           STREAMLIT APP                                  â”‚
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚  â”‚ Folder Upload    â”‚ (path input or multi-file upload)                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚           â”‚                                                              â”‚
â”‚           â–¼                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    FOR EACH IMAGE                                 â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ Step 1: Extract + Translate (Gemini 2.5 Flash)              â”‚ â”‚   â”‚
â”‚  â”‚  â”‚         One API call: OCR + Englishâ†’Hebrew translation      â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚                          â”‚                                        â”‚   â”‚
â”‚  â”‚                          â–¼                                        â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ Step 2: Dedup Check                                         â”‚ â”‚   â”‚
â”‚  â”‚  â”‚         First 100 chars of extracted text â†’ check DB        â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚                          â”‚                                        â”‚   â”‚
â”‚  â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚   â”‚
â”‚  â”‚              â”‚                       â”‚                           â”‚   â”‚
â”‚  â”‚           DUPLICATE               NEW PAGE                       â”‚   â”‚
â”‚  â”‚              â”‚                       â”‚                           â”‚   â”‚
â”‚  â”‚              â–¼                       â–¼                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚   â”‚
â”‚  â”‚  â”‚ Skip: Link to   â”‚     â”‚ Step 3: Edit Image                â”‚â”‚   â”‚
â”‚  â”‚  â”‚ existing output â”‚     â”‚ (Nano Banana Pro)                 â”‚â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ Same image, just swap text to     â”‚â”‚   â”‚
â”‚  â”‚                          â”‚ Hebrew - DO NOT regenerate        â”‚â”‚   â”‚
â”‚  â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                     â”‚
â”‚                                    â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ SQLite Database                                                   â”‚   â”‚
â”‚  â”‚ â€¢ text_fingerprint (first 100 chars)  â€¢ extracted_text           â”‚   â”‚
â”‚  â”‚ â€¢ translated_text_json                â€¢ status                    â”‚   â”‚
â”‚  â”‚ â€¢ output_filepath                     â€¢ error info                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                     â”‚
â”‚                                    â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Output Folder: translated_page_001.png, translated_page_002.png  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Google AI Models

| Purpose | Model ID | Notes |
|---------|----------|-------|
| Text extraction + translation | `gemini-2.5-flash` | Fast, cheap, good for OCR + translation |
| Image editing (text swap) | `gemini-3-pro-image-preview` | Nano Banana Pro - edits existing image, replaces text only |

**Important:** We use Nano Banana Pro for **image editing**, not generation. We send the original page and ask it to swap the text while preserving everything else.

---

## 4. Database Schema

```sql
CREATE TABLE pages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- Input
    original_filename TEXT NOT NULL,
    original_filepath TEXT NOT NULL,
    
    -- Deduplication (first 100 chars of extracted text, no normalization)
    text_fingerprint TEXT,
    
    -- Extracted & translated content
    extracted_text TEXT,          -- Full original English text
    translated_text_json TEXT,    -- {"translations": [...]}
    
    -- Output
    output_filepath TEXT,
    
    -- Status: pending, processing, completed, failed, duplicate
    status TEXT DEFAULT 'pending',
    duplicate_of_id INTEGER REFERENCES pages(id),
    
    -- Error handling
    retry_count INTEGER DEFAULT 0,
    last_error TEXT,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);

CREATE INDEX idx_fingerprint ON pages(text_fingerprint);
CREATE INDEX idx_status ON pages(status);
```

**Removed:** `books` table, `file_size_bytes`, `error_log_path`, complex status states, separate indexes for duplicates.

---

## 5. Core Code

### 5.1 Text Extraction + Translation (One API Call)

```python
from google import genai
from google.genai import types
from PIL import Image

client = genai.Client()

def extract_and_translate(image_path: str) -> dict:
    """
    Single API call: Extract English text AND translate to Hebrew.
    Returns both original text and translations.
    """
    image = Image.open(image_path)
    
    prompt = '''
    1. Extract ALL English text from this image exactly as written.
    2. Translate each text element to Hebrew.
    
    Return JSON:
    {
        "extracted_text": "full original English text here...",
        "translations": [
            {"english": "Mickey Mouse's Sugar Cookies", "hebrew": "×¢×•×’×™×•×ª ×”×¡×•×›×¨ ×©×œ ××™×§×™ ×××•×¡"},
            {"english": "1 egg", "hebrew": "×‘×™×¦×” ××—×ª"},
            ...
        ]
    }
    '''
    
    response = client.models.generate_content(
        model="gemini-2.5-flash",
        contents=[prompt, image]
    )
    
    return parse_json_response(response.text)
```

### 5.2 Deduplication Check

```python
def get_fingerprint(text: str) -> str:
    """First 100 characters, no normalization."""
    if not text or not text.strip():
        return "EMPTY_PAGE"
    return text.strip()[:100]

def check_duplicate(fingerprint: str) -> Optional[str]:
    """Returns output_filepath if duplicate exists, None otherwise."""
    with sqlite3.connect(DB_PATH) as conn:
        row = conn.execute(
            "SELECT output_filepath FROM pages WHERE text_fingerprint = ? AND status = 'completed'",
            (fingerprint,)
        ).fetchone()
        return row[0] if row else None
```

### 5.3 Image Editing (Nano Banana Pro)

```python
def edit_image_with_hebrew(image_path: str, translations: list) -> Image:
    """
    EDIT the original image - replace English text with Hebrew.
    This is NOT generating a new image from scratch.
    """
    image = Image.open(image_path)
    
    replacements = "\n".join([
        f'â€¢ "{t["english"]}" â†’ "{t["hebrew"]}"' 
        for t in translations
    ])
    
    prompt = f'''
    EDIT THIS IMAGE - DO NOT REGENERATE IT.
    
    This is a text replacement task. Take the uploaded image and replace 
    the English text with Hebrew translations. Everything else must remain 
    EXACTLY as it is in the original:
    
    âœ“ Keep the EXACT same illustrations and cartoon characters
    âœ“ Keep the EXACT same layout and positioning
    âœ“ Keep the EXACT same colors and backgrounds
    âœ“ Keep the EXACT same decorative elements
    âœ— Do NOT redraw or reimagine any part of the image
    âœ— Do NOT change anything except the text
    
    HEBREW TEXT POSITIONING (RTL RULES):
    - Hebrew reads RIGHT-TO-LEFT
    - Titles: Keep centered if originally centered
    - Paragraphs: Flip alignment (left-aligned English â†’ right-aligned Hebrew)
    - Lists/bullet points: Bullets move to the RIGHT side of text
    - Text boxes: Text starts from the RIGHT edge
    - Numbers in recipes (Â½ cup, 350Â°F): Keep as-is, they appear correctly in RTL
    - Keep text in the SAME position/area as the original English
    
    The ONLY change should be: English text â†’ Hebrew text (with proper RTL alignment)
    
    Text replacements to make:
    {replacements}
    '''
    
    response = client.models.generate_content(
        model="gemini-3-pro-image-preview",
        contents=[prompt, image],  # Original image sent for editing
        config=types.GenerateContentConfig(
            response_modalities=['TEXT', 'IMAGE']
        )
    )
    
    for part in response.parts:
        if part.inline_data is not None:
            return part.as_image()
    
    raise RuntimeError("No image in response")
```

### 5.4 Verification Step (Optional)

```python
def verify_translation(original_path: str, translated_path: str) -> dict:
    """
    Compare original and translated images to catch issues.
    Returns verification result with pass/fail and reason.
    
    Checks for:
    - Missing translations (English text still visible)
    - Broken layout (illustrations moved/distorted)
    - Unreadable Hebrew (garbled text)
    - Major visual differences
    """
    original = Image.open(original_path)
    translated = Image.open(translated_path)
    
    prompt = '''
    Compare these two images. The first is the original (English), 
    the second is the translated version (Hebrew).
    
    Check for these issues:
    1. MISSING TRANSLATION: Is any English text still visible in image 2?
    2. BROKEN LAYOUT: Are illustrations/graphics significantly different or distorted?
    3. UNREADABLE TEXT: Is the Hebrew text garbled or incorrectly rendered?
    4. ALIGNMENT ISSUES: Is Hebrew text properly right-aligned where appropriate?
    
    Respond with JSON:
    {
        "pass": true/false,
        "issues": ["list of issues found, or empty if pass"],
        "confidence": 0.0-1.0
    }
    
    Be strict - flag anything that looks wrong. It's better to have 
    false positives than miss real issues.
    '''
    
    response = client.models.generate_content(
        model="gemini-2.5-flash",  # Cheap model is fine for comparison
        contents=[prompt, original, translated]
    )
    
    return parse_json_response(response.text)


def process_single_page(image_path: str, verify: bool = False) -> dict:
    """Process one page with optional verification."""
    
    # Steps 1-4: Extract, translate, dedup check, edit image
    # ... (existing code) ...
    
    result = {
        "status": "completed",
        "output_path": output_path,
        "verification": None
    }
    
    # Step 5: Optional verification
    if verify:
        verification = verify_translation(image_path, output_path)
        result["verification"] = verification
        
        # Store in database
        update_verification_status(
            page_id, 
            passed=verification["pass"],
            issues=verification.get("issues", [])
        )
        
        if not verification["pass"]:
            result["status"] = "needs_review"
    
    return result


def get_verification_issues() -> list[dict]:
    """Get all pages that failed verification."""
    with sqlite3.connect(DB_PATH) as conn:
        rows = conn.execute(
            """SELECT original_filename, verification_issues 
               FROM pages 
               WHERE verification_passed = 0"""
        ).fetchall()
        
        return [
            {"filename": row[0], "reason": row[1]} 
            for row in rows
        ]
```

**Database schema addition:**

```sql
-- Add to pages table
ALTER TABLE pages ADD COLUMN verification_passed BOOLEAN;
ALTER TABLE pages ADD COLUMN verification_issues TEXT;
```

**When to use verification:**
- High-stakes books (professional publication)
- First run on a new book style (to calibrate quality)
- When previous batches had issues

**Cost impact:** ~33% more API calls (one extra Gemini Flash call per page)

### 5.5 Main Processing Flow

The main processing is now handled directly in the Streamlit app (Section 7) with proper `st.session_state` for pause/resume. The core logic per page is:

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(stop=stop_after_attempt(3), wait=wait_exponential(min=4, max=60))
def process_single_page(image_path: str, verify: bool = False) -> dict:
    """
    Process one page end-to-end.
    Returns dict with status, output_path, and optional verification result.
    """
    
    # Step 1: Extract + Translate (one API call)
    result = extract_and_translate(image_path)
    extracted_text = result["extracted_text"]
    translations = result["translations"]
    
    # Step 2: Dedup check
    fingerprint = get_fingerprint(extracted_text)
    existing = check_duplicate(fingerprint)
    
    if existing:
        record_duplicate(image_path, fingerprint, existing)
        return {"status": "duplicate", "output_path": existing}
    
    # Step 3: Register in DB
    page_id = register_page(image_path, fingerprint, extracted_text, translations)
    
    # Step 4: Edit image (replace English text with Hebrew)
    output_image = edit_image_with_hebrew(image_path, translations)
    output_path = save_image(output_image, image_path)
    
    # Step 5: Optional verification
    if verify:
        verification = verify_translation(image_path, output_path)
        update_verification_status(page_id, verification)
        
        if not verification["pass"]:
            mark_completed(page_id, output_path, status="needs_review")
            return {"status": "needs_review", "output_path": output_path, "verification": verification}
    
    mark_completed(page_id, output_path)
    return {"status": "completed", "output_path": output_path}
```

---

## 6. Batch Processing Mode (Optional - Up to 50% Cheaper)

For large books (50+ pages), users can opt for Gemini's Batch API which is significantly cheaper but processes overnight (up to 24 hours).

### 6.1 When to Use Batch Mode

| Book Size | Recommended Mode | Why |
|-----------|------------------|-----|
| 1-20 pages | Real-time | Fast, batch overhead not worth it |
| 20-50 pages | Either | User preference |
| 50+ pages | Batch | Significant cost savings |

### 6.2 Batch Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        BATCH MODE                                    â”‚
â”‚                                                                      â”‚
â”‚  1. User uploads folder + selects "Batch Mode (Cheaper, Overnight)" â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  2. Submit all images to Batch API for extraction + translation     â”‚
â”‚     (returns job ID, stored in database)                            â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  3. Show "Processing overnight - check back in 24 hours"            â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  4. User returns, clicks "Check Batch Status"                       â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  5. If complete: Retrieve translations, run image editing           â”‚
â”‚     (Image editing with Nano Banana runs real-time - fast since     â”‚
â”‚      all the text extraction/translation work is already done)      â”‚
â”‚                              â”‚                                       â”‚
â”‚                              â–¼                                       â”‚
â”‚  6. Save all translated images                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Note:** Only extraction + translation can be batched. Image editing (Nano Banana Pro) runs real-time, but it's quick since the translations are pre-computed.

### 6.3 Batch API Code

```python
from google import genai
from google.genai import types

def submit_batch_job(image_paths: list[str]) -> str:
    """
    Submit batch job for extraction + translation.
    Returns job ID for status checking later.
    """
    client = genai.Client()
    
    requests = []
    for i, image_path in enumerate(image_paths):
        image = Image.open(image_path)
        
        prompt = '''
        1. Extract ALL English text from this image exactly as written.
        2. Translate each text element to Hebrew.
        
        Return JSON:
        {
            "extracted_text": "...",
            "translations": [{"english": "...", "hebrew": "..."}, ...]
        }
        '''
        
        requests.append(types.BatchRequest(
            custom_id=f"page_{i:04d}_{Path(image_path).name}",
            request=types.GenerateContentRequest(
                model="gemini-2.5-flash",
                contents=[prompt, image]
            )
        ))
    
    batch_job = client.batches.create(
        requests=requests,
        config=types.BatchConfig(display_name="book_translation")
    )
    
    return batch_job.name


def check_batch_status(job_id: str) -> dict:
    """Check if batch job is complete."""
    client = genai.Client()
    job = client.batches.get(name=job_id)
    
    return {
        "status": job.state,  # PENDING, RUNNING, SUCCEEDED, FAILED
        "completed": job.succeeded_request_count,
        "total": job.total_request_count
    }


def process_batch_results(job_id: str, image_paths: list[str], output_folder: str):
    """
    Retrieve batch results and run image editing for each page.
    Called after batch job completes.
    """
    client = genai.Client()
    
    # Get all translation results
    results = {r.custom_id: r for r in client.batches.list_results(name=job_id)}
    
    for image_path in image_paths:
        custom_id = f"page_{...}_{Path(image_path).name}"
        result = results[custom_id]
        
        translations = parse_json_response(result.response.text)
        
        # Run image editing (real-time, but fast since translation is done)
        output_image = edit_image_with_hebrew(image_path, translations["translations"])
        save_image(output_image, output_folder, image_path)
```

### 6.4 Database Schema Addition for Batch Jobs

```sql
CREATE TABLE batch_jobs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    job_id TEXT NOT NULL,           -- Gemini batch job ID
    status TEXT DEFAULT 'pending',  -- pending, running, completed, failed
    total_pages INTEGER,
    completed_pages INTEGER DEFAULT 0,
    input_folder TEXT,
    output_folder TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);
```

---

## 7. Streamlit App

```python
import streamlit as st
from pathlib import Path

st.title("ğŸ“š Book Translator: English â†’ Hebrew")

# Initialize session state
if "processing" not in st.session_state:
    st.session_state.processing = False
    st.session_state.paused_at_checkpoint = False
    st.session_state.current_page = 0

# Input
input_folder = st.text_input("Input folder path:", "/path/to/book/pages")
output_folder = st.text_input("Output folder path:", "/path/to/output")

# Or file upload for cloud deployment
uploaded_files = st.file_uploader(
    "Or upload images directly:", 
    type=["png", "jpg", "jpeg", "webp"],
    accept_multiple_files=True
)

# Processing mode selection
mode = st.radio(
    "Processing mode:",
    ["âš¡ Real-time (instant, standard price)", "ğŸ’° Batch (overnight, ~50% cheaper)"],
    index=0
)

# Optional verification
verify = st.checkbox(
    "ğŸ” Enable verification (checks each translation, +33% cost)", 
    value=False
)

# Count pages to help user decide
page_count = len(list(Path(input_folder).glob("*.[jp][pn][g]*"))) if input_folder else 0
if page_count > 50:
    st.info(f"ğŸ“Š {page_count} pages detected. Batch mode recommended for cost savings.")

# Handle checkpoint pause (must be BEFORE the main processing block)
if st.session_state.paused_at_checkpoint:
    st.warning("âš ï¸ 300 pages processed. Please review output folder before continuing.")
    col1, col2 = st.columns(2)
    with col1:
        if st.button("âœ… Continue Processing"):
            st.session_state.paused_at_checkpoint = False
            st.rerun()
    with col2:
        if st.button("ğŸ›‘ Stop Here"):
            st.session_state.processing = False
            st.session_state.paused_at_checkpoint = False
            st.session_state.current_page = 0
            st.success("Processing stopped. Partial results saved.")
            st.rerun()

# Real-time mode
elif "Real-time" in mode:
    if st.button("ğŸš€ Start Translation") or st.session_state.processing:
        st.session_state.processing = True
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        image_files = sorted(Path(input_folder).glob("*.[jp][pn][g]*"))
        start_from = st.session_state.current_page
        
        for i, image_path in enumerate(image_files[start_from:], start=start_from):
            # Checkpoint at 300 pages
            if i == 300 and i > start_from:
                st.session_state.paused_at_checkpoint = True
                st.session_state.current_page = i
                st.rerun()
            
            # Process page
            try:
                result = process_single_page(str(image_path), verify=verify)
                status = "âœ…" if result["status"] == "completed" else "â­ï¸"
            except Exception as e:
                log_error(image_path, e)
                status = "âŒ"
            
            # Update progress
            progress_bar.progress((i + 1) / len(image_files))
            status_text.text(f"Page {i + 1}/{len(image_files)} {status}")
            st.session_state.current_page = i + 1
        
        # Done - reset state
        st.session_state.processing = False
        st.session_state.current_page = 0
        
        # Show verification issues if any
        if verify:
            issues = get_verification_issues()
            if issues:
                st.warning(f"âš ï¸ {len(issues)} pages flagged for review")
                with st.expander("View flagged pages"):
                    for issue in issues:
                        st.write(f"- {issue['filename']}: {issue['reason']}")
        
        st.success("Done!")
        st.download_button("ğŸ“¥ Download as ZIP", create_zip(output_folder))

# Batch mode
else:
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("ğŸ“¤ Submit Batch Job"):
            image_paths = sorted(Path(input_folder).glob("*.[jp][pn][g]*"))
            job_id = submit_batch_job(list(image_paths))
            save_batch_job(job_id, input_folder, output_folder, verify=verify)
            st.success(f"âœ… Batch submitted! Job ID: {job_id}")
            st.info("Check back in 24 hours to retrieve results.")
    
    with col2:
        if st.button("ğŸ”„ Check Batch Status"):
            job = get_latest_batch_job()
            if job:
                status = check_batch_status(job["job_id"])
                st.write(f"Status: {status['status']}")
                st.write(f"Progress: {status['completed']}/{status['total']} pages")
                
                if status["status"] == "SUCCEEDED":
                    if st.button("ğŸ“¥ Generate Translated Images"):
                        process_batch_results(
                            job["job_id"], 
                            job["image_paths"], 
                            output_folder,
                            verify=job.get("verify", False)
                        )
                        st.success("Done! All images translated.")
                        st.download_button("ğŸ“¥ Download as ZIP", create_zip(output_folder))
            else:
                st.warning("No pending batch jobs found.")
```

---

## 8. Project Structure

```
book-translator/
â”œâ”€â”€ app.py                 # Streamlit app (main entry point)
â”œâ”€â”€ translator.py          # Extract, translate, edit image
â”œâ”€â”€ database.py            # SQLite operations + deduplication
â”œâ”€â”€ batch.py               # Batch API operations (optional)
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .env.example
â”œâ”€â”€ README.md
â”‚
â”œâ”€â”€ data/
â”‚   â””â”€â”€ translator.db      # Auto-created
â”‚
â””â”€â”€ tests/
    â””â”€â”€ test_translator.py
```

---

## 9. Configuration

```bash
# .env
GEMINI_API_KEY=your_key_here
```

That's it. Other settings can be hardcoded or passed as function parameters:
- `MAX_RETRIES = 3`
- `REVIEW_THRESHOLD = 300`

---

## 10. Error Handling

- **Retry:** 3 attempts with exponential backoff (4s â†’ 8s â†’ 16s)
- **On failure:** Log to database `last_error` column, continue to next image
- **After processing:** Show list of failed pages with "Retry Failed" button

No separate error log files needed - everything is in the database.

---

## 11. What Was Removed (Simplifications)

| Removed | Why |
|---------|-----|
| `books` table | Over-engineering; just process folders |
| Stage 0 (separate OCR) | Combined with Stage 1 - one API call |
| 8 status states | Reduced to 5: pending, processing, completed, failed, duplicate |
| `Image Queue Manager` component | It's just a for loop |
| `file_size_bytes` column | Not needed |
| `error_log_path` column | Errors stored in `last_error` |
| `started_at` timestamp | Not useful |
| Separate config file | Just use .env for API key |
| 7 source files | Reduced to 4 (added batch.py) |

---

## 12. Key Decisions

1. **One API call for extraction + translation:** Simpler, still cheap with Gemini Flash.

2. **Dedup AFTER extraction:** Yes, we "waste" one API call if duplicate. But:
   - Extraction is cheap (Gemini Flash)
   - Code is much simpler
   - We get the translation cached even for duplicates (useful for debugging)

3. **No normalization for fingerprint:** First 100 chars raw is good enough for book pages.

4. **SQLite over JSON files:** Queryable, supports resume, handles concurrent access.

5. **Streamlit over CLI:** Visual progress, easy to use, good for non-technical users.

6. **Batch mode optional:** Real-time by default, batch for 50+ pages to save ~50% cost.

7. **RTL positioning in prompt:** Explicit rules for Hebrew text alignment (right-align paragraphs, flip bullet points).
